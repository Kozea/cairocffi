# coding: utf8
import re
import pycparser.c_generator

import textwrap


def parse_constant(node):
    if isinstance(node, pycparser.c_ast.Constant):
        return node.value
    elif isinstance(node, pycparser.c_ast.UnaryOp) and node.op == '-':
        return '-' + parse_constant(node.expr)
    else:
        raise TypeError(node)


class Visitor(pycparser.c_ast.NodeVisitor):
    def visit_Enum(self, node):
        value = 0
        for enumerator in node.values.enumerators:
            if enumerator.value is not None:
                value_string = parse_constant(enumerator.value)
                value = int(value_string, 0)
            else:
                value_string = str(value)
            assert enumerator.name.startswith('CAIRO_')  # len('CAIRO_') == 6
            print('%s = %s' % (enumerator.name[6:], value_string))
            value += 1
        print('')


xcb_typedefs = textwrap.dedent("""
    typedef void xcb_connection_t;
    typedef void xcb_drawable_t;
    typedef void xcb_visualtype_t;
    typedef void xcb_screen_t;
    typedef void xcb_render_pictforminfo_t;
    typedef void xcb_pixmap_t;
""")


def generate(include_dir):
    # Remove comments, preprocessor instructions and macros.
    source = re.sub(
        '/\*.*?\*/'
        '|CAIRO_(BEGIN|END)_DECLS'
        '|cairo_public '
        r'|^\s*#.*?[^\\]\n',
        '',
        ''.join(open('%s/cairo%s.h' % (include_dir, suffix), 'r').read()
                for suffix in ['', '-pdf', '-ps', '-svg', '-xcb']),
        flags=re.DOTALL | re.MULTILINE)
    print('# Generated by mkconstants.py\n')
    ast = pycparser.CParser().parse(xcb_typedefs + source)
    Visitor().visit(ast)
    source = pycparser.c_generator.CGenerator().visit(ast)

    try:
        # Since we're going to ffi.include() the real definitions for xcb_*_t
        # via xcffib, there's no need to include the headers here. However, the
        # C parser fails to parse things it doesn't know about, so we typedef
        # them all to void and strip them all out at the end. They won't ever
        # actually be compiled because of a similar try/except in __init__ that
        # doesn't add this header if it can't find xcffib to ffi.include()
        import xcffib

        # for now we're only implementing compat with py2cairo, which only
        # uses cairo_xcb_surface_create and cairo_xcb_surface_set_size. The
        # trailing ( is a cheap way of getting exactly these functions to
        # match.
        xcb_functions = [
            'cairo_xcb_surface_create(', 'cairo_xcb_surface_set_size(']

        filtered = []
        for line in source.split('\n'):
            ok = False

            if 'xcb' in line:
                if any([function in line for function in xcb_functions]):
                    ok = True
            else:
                ok = True

            if line in xcb_typedefs.split('\n'):
                ok = False

            if ok:
                filtered.append(line)

        source = '\n'.join(filtered)

    except ImportError:
        # filter all XCB related stuff out since we're not going to be defining XCB
        no_xcb = []
        for line in source.split('\n'):
            if 'xcb' not in line:
                no_xcb.append(line)
        source = '\n'.join(no_xcb)

    print('_CAIRO_HEADERS = r"""\n%s\n"""' % source.strip())


if __name__ == '__main__':
    generate('/usr/include/cairo')
