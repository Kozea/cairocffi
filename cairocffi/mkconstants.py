# coding: utf8
import re
import pycparser.c_generator
import cffi
import itertools


ENUM_CLASS = '''
class _Enum(int):
    _TYPENAME = None
    _INSTANCES = None
    _VALUES = None

    def __new__(cls, value, name):
        return int.__new__(cls, value)

    def __init__(self, value, name):
        int.__init__(self, value)
        self._name = name
        cls = type(self)
        if cls._INSTANCES is None:
            cls._INSTANCES = {}
        if cls._VALUES is None:
            cls._VALUES = {}
        cls._INSTANCES[value] = self
        cls._VALUES[name] = value

    def __str__(self):
        return self._name

    def __repr__(self):
        return "<%s %s(%d)>" % (self._TYPENAME, self._name, self)

    @classmethod
    def _from_enum(cls, value):
        return cls._INSTANCES.get(value, value)

    @classmethod
    def _to_enum(cls, value):
        if isinstance(value, compat.basestring):
            try:
                return cls._VALUES[value]
            except KeyError:
                raise ValueError(value)
        return value
'''


class Visitor(pycparser.c_ast.NodeVisitor):

    def __init__(self):
        pycparser.c_ast.NodeVisitor.__init__(self)
        self.enums = []

    def visit_Typedef(self, node):
        if isinstance(node.type.type, pycparser.c_ast.Enum):
            self.enums.append(node.name)


def generate(include_dir):
    # Remove comments, preprocessor instructions and macros.
    source = re.sub(
        b'/\*.*?\*/'
        b'|CAIRO_(BEGIN|END)_DECLS'
        b'|cairo_public '
        br'|^\s*#.*?[^\\]\n',
        b'',
        b''.join(open('%s/cairo%s.h' % (include_dir, suffix), 'rb').read()
                 for suffix in ['', '-pdf', '-ps', '-svg']),
        flags=re.DOTALL | re.MULTILINE)
    print('# Generated by mkconstants.py\n')
    print('from . import compat')

    # Sanitize the C code formatting
    ast = pycparser.CParser().parse(source)
    source = pycparser.c_generator.CGenerator().visit(ast)

    # Extract all typedef-ed enum types
    visitor = Visitor()
    visitor.visit(ast)
    enums = visitor.enums

    ffi = cffi.FFI()
    ffi.cdef(source)

    # The base enum class
    print(ENUM_CLASS)

    for enum_type in sorted(enums):
        if enum_type.startswith("cairo_") and enum_type.endswith("_t"):
            type_name = enum_type[6:-2].upper()

            # Get all integer values and names of the enum values
            enum_values = []
            common = 0
            for value, name in sorted(ffi.typeof(enum_type).elements.items()):
                if not name.startswith("CAIRO_"):
                    continue
                name = name[6:]
                # Find the common string part, and strip it from the value
                m = [a == b for a, b in zip(name, type_name)]
                common = len(list(itertools.takewhile(lambda x: x, m)))
                value_name = name[common:].lstrip("_")
                enum_values.append((value_name, value))

            # The common prefix, used as class name
            type_name = type_name[:common].rstrip("_")

            # The enum sunclasses
            print('')
            print('class _%s(_Enum):' % type_name.upper())
            print('    _TYPENAME = %r' % type_name.upper())
            print('')

            # these get included with the type prefix for backwards compat
            include_full = ["PS_LEVEL", "SVG_VERSION", "PDF_VERSION"]

            # create all value instances (which registeres them in the class)
            for name, value in enum_values:
                full_name = type_name + "_" + name
                if type_name in include_full:
                    name = full_name
                print("%s = _%s(%d, %r)" %
                      (full_name, type_name, value, name))
        print('')

    print('_CAIRO_HEADERS = r"""\n%s\n"""' % source.strip())


if __name__ == '__main__':
    generate('/usr/include/cairo')
